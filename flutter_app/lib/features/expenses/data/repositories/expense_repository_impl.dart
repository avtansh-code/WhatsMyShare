import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../domain/entities/expense_entity.dart';
import '../../domain/repositories/expense_repository.dart';
import '../datasources/expense_datasource.dart';
import '../models/expense_model.dart';

export '../models/expense_model.dart' show PayerInfoModel, ExpenseSplitModel;

/// Implementation of ExpenseRepository
class ExpenseRepositoryImpl implements ExpenseRepository {
  final ExpenseDatasource _datasource;

  ExpenseRepositoryImpl({required ExpenseDatasource datasource})
    : _datasource = datasource;

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpenses(
    String groupId,
  ) async {
    try {
      final expenses = await _datasource.getExpenses(groupId);
      return Right(expenses.map((e) => e.toEntity()).toList());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Stream<List<ExpenseEntity>> watchExpenses(String groupId) {
    return _datasource
        .watchExpenses(groupId)
        .map((expenses) => expenses.map((e) => e.toEntity()).toList());
  }

  @override
  Future<Either<Failure, ExpenseEntity>> getExpense(
    String groupId,
    String expenseId,
  ) async {
    try {
      final expense = await _datasource.getExpense(groupId, expenseId);
      return Right(expense.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseEntity>> createExpense({
    required String groupId,
    required String description,
    required int amount,
    required String currency,
    required ExpenseCategory category,
    required DateTime date,
    required List<PayerInfo> paidBy,
    required SplitType splitType,
    required List<ExpenseSplit> splits,
    List<String>? receiptUrls,
    String? notes,
  }) async {
    try {
      final now = DateTime.now();
      final expenseModel = ExpenseModel(
        id: '', // Will be generated by datasource
        groupId: groupId,
        description: description,
        amount: amount,
        currency: currency,
        category: category,
        date: date,
        paidBy: paidBy.map((p) => PayerInfoModel.fromEntity(p)).toList(),
        splitType: splitType,
        splits: splits.map((s) => ExpenseSplitModel.fromEntity(s)).toList(),
        receiptUrls: receiptUrls,
        notes: notes,
        createdBy: '', // Will be set by datasource
        status: ExpenseStatus.active,
        createdAt: now,
        updatedAt: now,
      );

      final createdExpense = await _datasource.createExpense(
        groupId,
        expenseModel,
      );
      return Right(createdExpense.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseEntity>> updateExpense({
    required String groupId,
    required String expenseId,
    String? description,
    int? amount,
    ExpenseCategory? category,
    DateTime? date,
    List<PayerInfo>? paidBy,
    SplitType? splitType,
    List<ExpenseSplit>? splits,
    List<String>? receiptUrls,
    String? notes,
  }) async {
    try {
      // First get the current expense
      final currentExpense = await _datasource.getExpense(groupId, expenseId);

      // Create updated model
      final updatedModel = ExpenseModel(
        id: expenseId,
        groupId: groupId,
        description: description ?? currentExpense.description,
        amount: amount ?? currentExpense.amount,
        currency: currentExpense.currency,
        category: category ?? currentExpense.category,
        date: date ?? currentExpense.date,
        paidBy: paidBy != null
            ? paidBy.map((p) => PayerInfoModel.fromEntity(p)).toList()
            : currentExpense.paidBy,
        splitType: splitType ?? currentExpense.splitType,
        splits: splits != null
            ? splits.map((s) => ExpenseSplitModel.fromEntity(s)).toList()
            : currentExpense.splits,
        receiptUrls: receiptUrls ?? currentExpense.receiptUrls,
        notes: notes ?? currentExpense.notes,
        createdBy: currentExpense.createdBy,
        status: currentExpense.status,
        chatMessageCount: currentExpense.chatMessageCount,
        createdAt: currentExpense.createdAt,
        updatedAt: DateTime.now(),
      );

      final updatedExpense = await _datasource.updateExpense(
        groupId,
        updatedModel,
      );
      return Right(updatedExpense.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteExpense(
    String groupId,
    String expenseId,
  ) async {
    try {
      await _datasource.deleteExpense(groupId, expenseId);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> permanentlyDeleteExpense(
    String groupId,
    String expenseId,
  ) async {
    try {
      await _datasource.permanentlyDeleteExpense(groupId, expenseId);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, String>> uploadReceipt({
    required String groupId,
    required String expenseId,
    required String filePath,
  }) async {
    try {
      final url = await _datasource.uploadReceipt(groupId, expenseId, filePath);
      return Right(url);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteReceipt({
    required String groupId,
    required String expenseId,
    required String receiptUrl,
  }) async {
    try {
      await _datasource.deleteReceipt(receiptUrl);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpensesByCategory(
    String groupId,
    ExpenseCategory category,
  ) async {
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final filtered = expenses
          .where((e) => e.category == category)
          .map((e) => e.toEntity())
          .toList();
      return Right(filtered);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpensesByDateRange(
    String groupId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final filtered = expenses
          .where(
            (e) =>
                e.date.isAfter(startDate) &&
                e.date.isBefore(endDate.add(const Duration(days: 1))),
          )
          .map((e) => e.toEntity())
          .toList();
      return Right(filtered);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getRecentExpenses({
    int limit = 10,
  }) async {
    // This would require a different query across all groups
    // For now, return empty list - implement when needed
    return const Right([]);
  }

  @override
  Future<Either<Failure, int>> getTotalExpenses(String groupId) async {
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final total = expenses.fold(0, (sum, e) => sum + e.amount);
      return Right(total);
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseStatistics>> getExpenseStatistics(
    String groupId,
  ) async {
    try {
      final expenses = await _datasource.getExpenses(groupId);

      if (expenses.isEmpty) {
        return const Right(
          ExpenseStatistics(
            totalAmount: 0,
            expenseCount: 0,
            byCategory: {},
            byPayer: {},
          ),
        );
      }

      final totalAmount = expenses.fold(0, (sum, e) => sum + e.amount);

      // Group by category
      final byCategory = <ExpenseCategory, int>{};
      for (final expense in expenses) {
        byCategory[expense.category] =
            (byCategory[expense.category] ?? 0) + expense.amount;
      }

      // Group by payer
      final byPayer = <String, int>{};
      for (final expense in expenses) {
        for (final payer in expense.paidBy) {
          byPayer[payer.userId] = (byPayer[payer.userId] ?? 0) + payer.amount;
        }
      }

      // Find oldest and newest
      final sorted = expenses.toList()
        ..sort((a, b) => a.date.compareTo(b.date));

      return Right(
        ExpenseStatistics(
          totalAmount: totalAmount,
          expenseCount: expenses.length,
          byCategory: byCategory,
          byPayer: byPayer,
          oldestExpense: sorted.first.date,
          newestExpense: sorted.last.date,
        ),
      );
    } on ServerException catch (e) {
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}
