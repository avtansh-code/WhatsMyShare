import 'package:dartz/dartz.dart';

import '../../../../core/errors/exceptions.dart';
import '../../../../core/errors/failures.dart';
import '../../../../core/services/logging_service.dart';
import '../../domain/entities/expense_entity.dart';
import '../../domain/repositories/expense_repository.dart';
import '../datasources/expense_datasource.dart';
import '../models/expense_model.dart';

export '../models/expense_model.dart' show PayerInfoModel, ExpenseSplitModel;

/// Implementation of ExpenseRepository
class ExpenseRepositoryImpl implements ExpenseRepository {
  final ExpenseDatasource _datasource;
  final LoggingService _log = LoggingService();

  ExpenseRepositoryImpl({required ExpenseDatasource datasource})
    : _datasource = datasource {
    _log.debug('ExpenseRepository initialized', tag: LogTags.expenses);
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpenses(
    String groupId,
  ) async {
    _log.debug(
      'Getting expenses',
      tag: LogTags.expenses,
      data: {'groupId': groupId},
    );
    try {
      final expenses = await _datasource.getExpenses(groupId);
      _log.info(
        'Expenses fetched',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'count': expenses.length},
      );
      return Right(expenses.map((e) => e.toEntity()).toList());
    } on ServerException catch (e) {
      _log.error(
        'Server error getting expenses',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting expenses',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Stream<List<ExpenseEntity>> watchExpenses(String groupId) {
    _log.debug(
      'Setting up expenses stream',
      tag: LogTags.expenses,
      data: {'groupId': groupId},
    );
    return _datasource.watchExpenses(groupId).map((expenses) {
      _log.debug(
        'Expenses stream updated',
        tag: LogTags.expenses,
        data: {'count': expenses.length},
      );
      return expenses.map((e) => e.toEntity()).toList();
    });
  }

  @override
  Future<Either<Failure, ExpenseEntity>> getExpense(
    String groupId,
    String expenseId,
  ) async {
    _log.debug(
      'Getting expense',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      final expense = await _datasource.getExpense(groupId, expenseId);
      _log.info(
        'Expense fetched',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'description': expense.description},
      );
      return Right(expense.toEntity());
    } on ServerException catch (e) {
      _log.error(
        'Server error getting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseEntity>> createExpense({
    required String groupId,
    required String description,
    required int amount,
    required String currency,
    required ExpenseCategory category,
    required DateTime date,
    required List<PayerInfo> paidBy,
    required SplitType splitType,
    required List<ExpenseSplit> splits,
    List<String>? receiptUrls,
    String? notes,
  }) async {
    _log.info(
      'Creating expense',
      tag: LogTags.expenses,
      data: {
        'groupId': groupId,
        'description': description,
        'amount': amount,
        'splitType': splitType.name,
      },
    );
    try {
      final now = DateTime.now();
      final expenseModel = ExpenseModel(
        id: '', // Will be generated by datasource
        groupId: groupId,
        description: description,
        amount: amount,
        currency: currency,
        category: category,
        date: date,
        paidBy: paidBy.map((p) => PayerInfoModel.fromEntity(p)).toList(),
        splitType: splitType,
        splits: splits.map((s) => ExpenseSplitModel.fromEntity(s)).toList(),
        receiptUrls: receiptUrls,
        notes: notes,
        createdBy: '', // Will be set by datasource
        status: ExpenseStatus.active,
        createdAt: now,
        updatedAt: now,
      );

      final createdExpense = await _datasource.createExpense(
        groupId,
        expenseModel,
      );
      _log.info(
        'Expense created',
        tag: LogTags.expenses,
        data: {'expenseId': createdExpense.id, 'amount': amount},
      );
      return Right(createdExpense.toEntity());
    } on ServerException catch (e) {
      _log.error(
        'Server error creating expense',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error creating expense',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseEntity>> updateExpense({
    required String groupId,
    required String expenseId,
    String? description,
    int? amount,
    ExpenseCategory? category,
    DateTime? date,
    List<PayerInfo>? paidBy,
    SplitType? splitType,
    List<ExpenseSplit>? splits,
    List<String>? receiptUrls,
    String? notes,
  }) async {
    _log.info(
      'Updating expense',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      // First get the current expense
      final currentExpense = await _datasource.getExpense(groupId, expenseId);

      // Create updated model
      final updatedModel = ExpenseModel(
        id: expenseId,
        groupId: groupId,
        description: description ?? currentExpense.description,
        amount: amount ?? currentExpense.amount,
        currency: currentExpense.currency,
        category: category ?? currentExpense.category,
        date: date ?? currentExpense.date,
        paidBy: paidBy != null
            ? paidBy.map((p) => PayerInfoModel.fromEntity(p)).toList()
            : currentExpense.paidBy,
        splitType: splitType ?? currentExpense.splitType,
        splits: splits != null
            ? splits.map((s) => ExpenseSplitModel.fromEntity(s)).toList()
            : currentExpense.splits,
        receiptUrls: receiptUrls ?? currentExpense.receiptUrls,
        notes: notes ?? currentExpense.notes,
        createdBy: currentExpense.createdBy,
        status: currentExpense.status,
        chatMessageCount: currentExpense.chatMessageCount,
        createdAt: currentExpense.createdAt,
        updatedAt: DateTime.now(),
      );

      final updatedExpense = await _datasource.updateExpense(
        groupId,
        updatedModel,
      );
      _log.info(
        'Expense updated',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId},
      );
      return Right(updatedExpense.toEntity());
    } on ServerException catch (e) {
      _log.error(
        'Server error updating expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error updating expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteExpense(
    String groupId,
    String expenseId,
  ) async {
    _log.info(
      'Deleting expense (soft)',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      await _datasource.deleteExpense(groupId, expenseId);
      _log.info(
        'Expense deleted',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId},
      );
      return const Right(null);
    } on ServerException catch (e) {
      _log.error(
        'Server error deleting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error deleting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> permanentlyDeleteExpense(
    String groupId,
    String expenseId,
  ) async {
    _log.warning(
      'Permanently deleting expense',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      await _datasource.permanentlyDeleteExpense(groupId, expenseId);
      _log.info(
        'Expense permanently deleted',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId},
      );
      return const Right(null);
    } on ServerException catch (e) {
      _log.error(
        'Server error permanently deleting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error permanently deleting expense',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, String>> uploadReceipt({
    required String groupId,
    required String expenseId,
    required String filePath,
  }) async {
    _log.info(
      'Uploading receipt',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      final url = await _datasource.uploadReceipt(groupId, expenseId, filePath);
      _log.info(
        'Receipt uploaded',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId},
      );
      return Right(url);
    } on ServerException catch (e) {
      _log.error(
        'Server error uploading receipt',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error uploading receipt',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteReceipt({
    required String groupId,
    required String expenseId,
    required String receiptUrl,
  }) async {
    _log.info(
      'Deleting receipt',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'expenseId': expenseId},
    );
    try {
      await _datasource.deleteReceipt(receiptUrl);
      _log.info(
        'Receipt deleted',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId},
      );
      return const Right(null);
    } on ServerException catch (e) {
      _log.error(
        'Server error deleting receipt',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error deleting receipt',
        tag: LogTags.expenses,
        data: {'expenseId': expenseId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpensesByCategory(
    String groupId,
    ExpenseCategory category,
  ) async {
    _log.debug(
      'Getting expenses by category',
      tag: LogTags.expenses,
      data: {'groupId': groupId, 'category': category.name},
    );
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final filtered = expenses
          .where((e) => e.category == category)
          .map((e) => e.toEntity())
          .toList();
      _log.info(
        'Expenses by category fetched',
        tag: LogTags.expenses,
        data: {'category': category.name, 'count': filtered.length},
      );
      return Right(filtered);
    } on ServerException catch (e) {
      _log.error(
        'Server error getting expenses by category',
        tag: LogTags.expenses,
        data: {'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting expenses by category',
        tag: LogTags.expenses,
        data: {'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getExpensesByDateRange(
    String groupId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    _log.debug(
      'Getting expenses by date range',
      tag: LogTags.expenses,
      data: {
        'groupId': groupId,
        'startDate': startDate.toIso8601String(),
        'endDate': endDate.toIso8601String(),
      },
    );
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final filtered = expenses
          .where(
            (e) =>
                e.date.isAfter(startDate) &&
                e.date.isBefore(endDate.add(const Duration(days: 1))),
          )
          .map((e) => e.toEntity())
          .toList();
      _log.info(
        'Expenses by date range fetched',
        tag: LogTags.expenses,
        data: {'count': filtered.length},
      );
      return Right(filtered);
    } on ServerException catch (e) {
      _log.error(
        'Server error getting expenses by date range',
        tag: LogTags.expenses,
        data: {'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting expenses by date range',
        tag: LogTags.expenses,
        data: {'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ExpenseEntity>>> getRecentExpenses({
    int limit = 10,
  }) async {
    _log.debug(
      'Getting recent expenses',
      tag: LogTags.expenses,
      data: {'limit': limit},
    );
    // This would require a different query across all groups
    // For now, return empty list - implement when needed
    return const Right([]);
  }

  @override
  Future<Either<Failure, int>> getTotalExpenses(String groupId) async {
    _log.debug(
      'Getting total expenses',
      tag: LogTags.expenses,
      data: {'groupId': groupId},
    );
    try {
      final expenses = await _datasource.getExpenses(groupId);
      final total = expenses.fold(0, (sum, e) => sum + e.amount);
      _log.info(
        'Total expenses calculated',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'total': total},
      );
      return Right(total);
    } on ServerException catch (e) {
      _log.error(
        'Server error getting total expenses',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting total expenses',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ExpenseStatistics>> getExpenseStatistics(
    String groupId,
  ) async {
    _log.debug(
      'Getting expense statistics',
      tag: LogTags.expenses,
      data: {'groupId': groupId},
    );
    try {
      final expenses = await _datasource.getExpenses(groupId);

      if (expenses.isEmpty) {
        _log.debug(
          'No expenses found for statistics',
          tag: LogTags.expenses,
          data: {'groupId': groupId},
        );
        return const Right(
          ExpenseStatistics(
            totalAmount: 0,
            expenseCount: 0,
            byCategory: {},
            byPayer: {},
          ),
        );
      }

      final totalAmount = expenses.fold(0, (sum, e) => sum + e.amount);

      // Group by category
      final byCategory = <ExpenseCategory, int>{};
      for (final expense in expenses) {
        byCategory[expense.category] =
            (byCategory[expense.category] ?? 0) + expense.amount;
      }

      // Group by payer
      final byPayer = <String, int>{};
      for (final expense in expenses) {
        for (final payer in expense.paidBy) {
          byPayer[payer.userId] = (byPayer[payer.userId] ?? 0) + payer.amount;
        }
      }

      // Find oldest and newest
      final sorted = expenses.toList()
        ..sort((a, b) => a.date.compareTo(b.date));

      _log.info(
        'Expense statistics calculated',
        tag: LogTags.expenses,
        data: {
          'groupId': groupId,
          'totalAmount': totalAmount,
          'expenseCount': expenses.length,
        },
      );
      return Right(
        ExpenseStatistics(
          totalAmount: totalAmount,
          expenseCount: expenses.length,
          byCategory: byCategory,
          byPayer: byPayer,
          oldestExpense: sorted.first.date,
          newestExpense: sorted.last.date,
        ),
      );
    } on ServerException catch (e) {
      _log.error(
        'Server error getting expense statistics',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.message},
      );
      return Left(ServerFailure(message: e.message));
    } catch (e) {
      _log.error(
        'Unexpected error getting expense statistics',
        tag: LogTags.expenses,
        data: {'groupId': groupId, 'error': e.toString()},
      );
      return Left(ServerFailure(message: e.toString()));
    }
  }
}
